use chrono::{DateTime, Utc};
use keradb::Database;
use serde::{Deserialize, Serialize};
use std::path::PathBuf;

const SYSTEM_DB_NAME: &str = ".nosqlite_system.db";
const CONNECTIONS_COLLECTION: &str = "connections";
const METRICS_COLLECTION: &str = "metrics";

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct DatabaseConnection {
    pub id: String,
    pub path: String,
    pub created_at: DateTime<Utc>,
    pub last_accessed: DateTime<Utc>,
    pub access_count: u64,
    pub collections_count: usize,
    pub total_documents: usize,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct PerformanceMetric {
    pub id: String,
    pub database_path: String,
    pub operation: String,
    pub duration_ms: u64,
    pub timestamp: DateTime<Utc>,
}

pub struct SystemDatabase {
    db: Database,
}

impl SystemDatabase {
    /// Get the system database path in an OS-agnostic way
    fn get_system_db_path() -> Result<PathBuf, std::io::Error> {
        let home = if cfg!(target_os = "windows") {
            std::env::var("USERPROFILE")
                .or_else(|_| std::env::var("HOMEDRIVE")
                    .and_then(|drive| std::env::var("HOMEPATH")
                        .map(|path| format!("{}{}", drive, path))))
                .map_err(|_| std::io::Error::new(
                    std::io::ErrorKind::NotFound,
                    "Could not determine user home directory"
                ))?
        } else {
            std::env::var("HOME").map_err(|_| std::io::Error::new(
                std::io::ErrorKind::NotFound,
                "Could not determine user home directory"
            ))?
        };

        let mut path = PathBuf::from(home);
        path.push(".nosqlite");
        
        // Create the directory if it doesn't exist
        if !path.exists() {
            std::fs::create_dir_all(&path)?;
        }
        
        path.push(SYSTEM_DB_NAME);
        Ok(path)
    }

    /// Initialize or open the system database
    pub fn init() -> Result<Self, Box<dyn std::error::Error>> {
        let db_path = Self::get_system_db_path()?;
        
        let db = if db_path.exists() {
            Database::open(&db_path)?
        } else {
            log::info!("Creating system database at: {}", db_path.display());
            Database::create(&db_path)?
        };

        Ok(Self { db })
    }

    /// Register a new database connection or update existing
    pub fn register_connection(&self, path: &str) -> Result<String, Box<dyn std::error::Error>> {
        let now = Utc::now();
        
        // Check if connection already exists
        if let Ok((id, existing)) = self.find_connection_by_path(path) {
            // Update existing connection
            let updated = DatabaseConnection {
                id: id.clone(),
                path: path.to_string(),
                created_at: existing.created_at,
                last_accessed: now,
                access_count: existing.access_count + 1,
                collections_count: existing.collections_count,
                total_documents: existing.total_documents,
            };
            
            let doc = serde_json::to_value(&updated)?;
            self.db.update(CONNECTIONS_COLLECTION, &id, doc)?;
            self.db.sync()?;
            return Ok(id);
        }

        // Create new connection
        let connection = DatabaseConnection {
            id: String::new(), // Will be generated by insert
            path: path.to_string(),
            created_at: now,
            last_accessed: now,
            access_count: 1,
            collections_count: 0,
            total_documents: 0,
        };

        let doc = serde_json::to_value(&connection)?;
        let id = self.db.insert(CONNECTIONS_COLLECTION, doc)?;
        self.db.sync()?;
        
        Ok(id)
    }

    /// Update database statistics
    pub fn update_connection_stats(
        &self,
        path: &str,
        collections_count: usize,
        total_documents: usize,
    ) -> Result<(), Box<dyn std::error::Error>> {
        if let Ok((id, mut conn)) = self.find_connection_by_path(path) {
            conn.collections_count = collections_count;
            conn.total_documents = total_documents;
            conn.last_accessed = Utc::now();
            
            let doc = serde_json::to_value(&conn)?;
            self.db.update(CONNECTIONS_COLLECTION, &id, doc)?;
            self.db.sync()?;
        }
        Ok(())
    }

    /// Find connection by database path
    /// Returns (document_id, connection) tuple
    fn find_connection_by_path(&self, path: &str) -> Result<(String, DatabaseConnection), Box<dyn std::error::Error>> {
        let docs = self.db.find_all(CONNECTIONS_COLLECTION, None, None)?;
        
        for doc in docs {
            let doc_value = doc.to_value();
            
            // Extract the _id separately
            let doc_id = doc_value.get("_id")
                .and_then(|v| v.as_str())
                .ok_or("Missing _id field")?
                .to_string();
            
            // Deserialize the connection
            let conn: DatabaseConnection = serde_json::from_value(doc_value)?;
            
            if conn.path == path {
                return Ok((doc_id, conn));
            }
        }
        
        Err("Connection not found".into())
    }

    /// Get all registered connections
    pub fn list_connections(&self) -> Result<Vec<DatabaseConnection>, Box<dyn std::error::Error>> {
        let docs = self.db.find_all(CONNECTIONS_COLLECTION, None, None)?;
        
        let mut connections = Vec::new();
        for doc in docs {
            let doc_value = doc.to_value();
            
            // Deserialize the connection (serde will ignore the _id field if not in the struct)
            if let Ok(conn) = serde_json::from_value::<DatabaseConnection>(doc_value) {
                connections.push(conn);
            }
        }
        
        // Sort by last accessed (most recent first)
        connections.sort_by(|a, b| b.last_accessed.cmp(&a.last_accessed));
        
        Ok(connections)
    }

    /// Remove a connection from the system database
    pub fn remove_connection(&self, path: &str) -> Result<(), Box<dyn std::error::Error>> {
        if let Ok((id, _conn)) = self.find_connection_by_path(path) {
            self.db.delete(CONNECTIONS_COLLECTION, &id)?;
            self.db.sync()?;
        }
        Ok(())
    }

    /// Record a performance metric
    pub fn record_metric(
        &self,
        database_path: &str,
        operation: &str,
        duration_ms: u64,
    ) -> Result<(), Box<dyn std::error::Error>> {
        let metric = PerformanceMetric {
            id: String::new(),
            database_path: database_path.to_string(),
            operation: operation.to_string(),
            duration_ms,
            timestamp: Utc::now(),
        };

        let doc = serde_json::to_value(&metric)?;
        self.db.insert(METRICS_COLLECTION, doc)?;
        
        // Only sync every 10 metrics to reduce I/O
        // In production, you might want to sync periodically instead
        Ok(())
    }

    /// Get recent metrics for a database
    pub fn get_metrics(
        &self,
        database_path: &str,
        limit: Option<usize>,
    ) -> Result<Vec<PerformanceMetric>, Box<dyn std::error::Error>> {
        let docs = self.db.find_all(METRICS_COLLECTION, None, None)?;
        
        let mut metrics = Vec::new();
        for doc in docs {
            let doc_value = doc.to_value();
            
            // Deserialize the metric (serde will ignore the _id field if not in the struct)
            if let Ok(metric) = serde_json::from_value::<PerformanceMetric>(doc_value) {
                if metric.database_path == database_path {
                    metrics.push(metric);
                }
            }
        }
        
        // Sort by timestamp (most recent first)
        metrics.sort_by(|a, b| b.timestamp.cmp(&a.timestamp));
        
        if let Some(limit) = limit {
            metrics.truncate(limit);
        }
        
        Ok(metrics)
    }

    /// Get system-wide statistics
    pub fn get_system_stats(&self) -> Result<serde_json::Value, Box<dyn std::error::Error>> {
        let connections = self.list_connections()?;
        let total_databases = connections.len();
        let total_collections: usize = connections.iter().map(|c| c.collections_count).sum();
        let total_documents: usize = connections.iter().map(|c| c.total_documents).sum();
        
        Ok(serde_json::json!({
            "total_databases": total_databases,
            "total_collections": total_collections,
            "total_documents": total_documents,
            "connections": connections,
        }))
    }
}
